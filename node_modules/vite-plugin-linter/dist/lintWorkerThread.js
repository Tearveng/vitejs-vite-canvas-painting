"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWorkerThreads = void 0;
const path_1 = __importDefault(require("path"));
const vite_1 = require("vite");
const worker_threads_1 = require("worker_threads");
function createWorkerThreads(command, pluginName, linters) {
    let workersByLinterName = {};
    for (const linter of linters) {
        const data = {
            command: command,
            linterName: linter.name,
            pluginName: pluginName,
            workingDirectory: process.cwd(),
        };
        workersByLinterName[linter.name] = new worker_threads_1.Worker(path_1.default.join(__dirname, "lintWorkerThread.js"), { workerData: data });
    }
    return workersByLinterName;
}
exports.createWorkerThreads = createWorkerThreads;
async function init(data) {
    const config = await (0, vite_1.resolveConfig)({ root: data.workingDirectory }, data.command);
    const plugin = config.plugins.find((p) => p.name === data.pluginName);
    if (!plugin) {
        throw new Error(`Could not find plugin ${data.pluginName}`);
    }
    const linter = plugin.getLinter(data.linterName);
    if (!linter) {
        throw new Error(`Could not find linter ${data.linterName}`);
    }
    worker_threads_1.parentPort.on("message", async (files) => {
        switch (data.command) {
            case "build":
                const buildResult = await linter.lintBuild(files);
                const buildMessage = {
                    files: files,
                    linterName: data.linterName,
                    result: { build: buildResult },
                };
                const functions = removeFunctionsFromObject(buildMessage);
                worker_threads_1.parentPort.postMessage(buildMessage);
                restoreFunctionsToObject(buildMessage, functions);
                break;
            case "serve":
                linter.lintServe(files, (serveResult) => {
                    if (serveResult) {
                        const serveMessage = {
                            files: files,
                            linterName: data.linterName,
                            result: { serve: serveResult },
                        };
                        const functions = removeFunctionsFromObject(serveMessage);
                        worker_threads_1.parentPort.postMessage(serveMessage);
                        restoreFunctionsToObject(serveMessage, functions);
                    }
                });
                break;
            default:
                throw new Error(`Uknown command ${data.command}`);
        }
    });
}
function removeFunctionsFromObject(object, maxDepth = 10) {
    const record = object;
    const functions = [];
    for (const key of Object.keys(record)) {
        if (typeof record[key] === "function") {
            functions.push({ function: record[key], key: key, source: record });
            delete record[key];
        }
        else if (typeof record[key] === typeof object &&
            record[key] !== null &&
            maxDepth > 0) {
            functions.push(...removeFunctionsFromObject(record[key], maxDepth - 1));
        }
    }
    return functions;
}
function restoreFunctionsToObject(object, functions, maxDepth = 10) {
    const record = object;
    const functionInfos = functions.filter((f) => f.source === record);
    for (const functionInfo of functionInfos) {
        record[functionInfo.key] = functionInfo.function;
    }
    for (const key of Object.keys(record)) {
        if (typeof record[key] === typeof object &&
            record[key] !== null &&
            maxDepth > 0) {
            restoreFunctionsToObject(record[key], functions, maxDepth - 1);
        }
    }
}
if (worker_threads_1.workerData) {
    init(worker_threads_1.workerData);
}
