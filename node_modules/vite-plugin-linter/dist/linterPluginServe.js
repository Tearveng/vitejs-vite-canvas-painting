"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.servePluginName = void 0;
const chokidar_1 = require("chokidar");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const lintWorkerThread_1 = require("./lintWorkerThread");
const utils_1 = require("./utils");
exports.servePluginName = "vite-plugin-linter-serve";
const clientEventName = "eslint-warn";
const clientJs = `
  if (import.meta.hot) {
    fetch("/eslint.json")
      .then(r => r.json())
      .then(response => {
        if (response) {
          for (let line of response) {
            console.warn(line);
          }
        }
      })
      .catch(e => console.error(e));

    import.meta.hot.on("${clientEventName}", d => console.warn(d));
  }
`;
function linterPluginServe(options = {}, fileFilter) {
    var _a, _b;
    let devServer = null;
    const includeMode = (_b = (_a = options.serve) === null || _a === void 0 ? void 0 : _a.includeMode) !== null && _b !== void 0 ? _b : "processedFiles";
    let injectedFile = null;
    let lintFiles = [];
    let processingTimeout;
    let workersByLinterName = {};
    let dataByFileNameByLinterName = {};
    for (const linter of options.linters) {
        dataByFileNameByLinterName[linter.name] = {};
    }
    async function getFormattedOutput(linter) {
        const dataByFileName = dataByFileNameByLinterName[linter.name];
        const allData = [];
        for (const file of Object.keys(dataByFileName)) {
            allData.push(dataByFileName[file]);
        }
        if (allData.length > 0) {
            return await linter.format(allData);
        }
        return "";
    }
    async function onWorkerMessage(message, pluginContext) {
        const dataByFileName = dataByFileNameByLinterName[message.linterName];
        for (const file of message.files) {
            if (file in message.result.serve) {
                dataByFileName[file] = message.result.serve[file];
            }
            else if (file in dataByFileName) {
                delete dataByFileName[file];
            }
        }
        const linter = options.linters.find((l) => l.name === message.linterName);
        const output = await getFormattedOutput(linter);
        if (output) {
            pluginContext.warn(output);
            if (devServer) {
                devServer.ws.send({
                    event: clientEventName,
                    data: output,
                    type: "custom",
                });
            }
        }
    }
    async function processFiles() {
        const files = [...lintFiles];
        if (includeMode !== "filesInFolder") {
            lintFiles = [];
        }
        for (const linter of options.linters) {
            workersByLinterName[linter.name].postMessage(files);
        }
    }
    function watchDirectory(directory) {
        function onChange(fsPath) {
            const normalizedPath = (0, utils_1.normalizePath)(fsPath);
            let changed = false;
            if (fileFilter(fsPath)) {
                if (includeMode === "filesInFolder" &&
                    !lintFiles.includes(normalizedPath)) {
                    lintFiles.push(normalizedPath);
                }
                changed = true;
            }
            else if (fs_1.default.existsSync(fsPath) && fs_1.default.lstatSync(fsPath).isDirectory()) {
                const children = (0, utils_1.readAllFiles)(fsPath, fileFilter).map((f) => (0, utils_1.normalizePath)(f));
                if (includeMode === "filesInFolder") {
                    for (const child of children) {
                        if (!lintFiles.includes(child)) {
                            lintFiles.push(child);
                            changed = true;
                        }
                    }
                    for (let index = lintFiles.length - 1; index >= 0; index--) {
                        const file = lintFiles[index];
                        if (file.startsWith(normalizedPath) && !children.includes(file)) {
                            lintFiles.splice(index, 1);
                            changed = true;
                        }
                    }
                }
                for (const linter of options.linters) {
                    const dataByFileName = dataByFileNameByLinterName[linter.name];
                    for (const file of Object.keys(dataByFileName)) {
                        if (file.startsWith(normalizedPath) && !children.includes(file)) {
                            delete dataByFileName[file];
                        }
                    }
                }
            }
            return changed;
        }
        let watchTimeout;
        let paths = [];
        function onEvent(fsPath) {
            // Ignore duplicate events via a short timeout
            clearTimeout(watchTimeout);
            if (!paths.includes(fsPath)) {
                paths.push(fsPath);
            }
            watchTimeout = setTimeout(() => {
                let changed = false;
                for (const path of paths) {
                    if (onChange(path)) {
                        changed = true;
                    }
                }
                if (includeMode === "filesInFolder" && changed) {
                    processFiles();
                }
                paths = [];
            }, 100);
        }
        // fs.watch recursive is not supported on Linux and chokidar locks folders on Windows
        if (process.platform === "linux") {
            (0, chokidar_1.watch)(directory, {
                ignored: /node_modules/,
                ignoreInitial: true,
                persistent: false,
            }).on("all", (event, fsPath) => {
                switch (event) {
                    case "add":
                        onEvent(fsPath);
                        break;
                    case "unlink":
                        const parentDirPath = path_1.default.resolve(fsPath, "..");
                        onEvent(parentDirPath);
                        break;
                }
            });
        }
        else {
            fs_1.default.watch(directory, { persistent: false, recursive: true }, (event, fileName) => {
                if (fileName) {
                    onEvent(path_1.default.join(directory, fileName));
                }
            });
        }
    }
    return {
        apply: "serve",
        name: exports.servePluginName,
        buildStart() {
            workersByLinterName = (0, lintWorkerThread_1.createWorkerThreads)("serve", exports.servePluginName, options.linters);
            for (const linterName of Object.keys(workersByLinterName)) {
                const worker = workersByLinterName[linterName];
                worker.on("message", (message) => onWorkerMessage(message, this));
            }
            const currentDirectory = process.cwd();
            watchDirectory(currentDirectory);
            if (includeMode === "filesInFolder") {
                lintFiles = (0, utils_1.readAllFiles)(currentDirectory, fileFilter).map((f) => (0, utils_1.normalizePath)(f));
                setTimeout(() => processFiles());
            }
        },
        configureServer(server) {
            devServer = server;
            devServer.middlewares.use(async (req, res, next) => {
                if (req.url === "/eslint.json") {
                    const outputs = [];
                    for (const linter of options.linters) {
                        const output = await getFormattedOutput(linter);
                        if (output) {
                            outputs.push(output);
                        }
                    }
                    res.setHeader("Content-Type", "application/json");
                    res.write(JSON.stringify(outputs), "utf-8");
                    res.end();
                }
                else {
                    next();
                }
            });
        },
        getLinter(name) {
            return options.linters.find((l) => l.name === name);
        },
        load(id) {
            const file = (0, utils_1.normalizePath)(id);
            if (options.injectFile) {
                if (file === (0, utils_1.normalizePath)(options.injectFile)) {
                    const content = fs_1.default.readFileSync(id);
                    return content + clientJs;
                }
            }
            else if ((injectedFile === null &&
                !file.startsWith("node_modules/") &&
                fs_1.default.existsSync(file)) ||
                file === injectedFile) {
                injectedFile = file;
                const content = fs_1.default.readFileSync(id);
                return content + clientJs;
            }
            return null;
        },
        async transform(code, id) {
            if (!fileFilter(id) || includeMode === "filesInFolder") {
                return null;
            }
            const file = (0, utils_1.normalizePath)(id);
            if (fs_1.default.existsSync(file)) {
                lintFiles.push(file);
            }
            const pluginContext = this;
            clearTimeout(processingTimeout);
            processingTimeout = setTimeout(() => processFiles().catch((ex) => pluginContext.error(ex)), 1000);
            return null;
        },
    };
}
exports.default = linterPluginServe;
