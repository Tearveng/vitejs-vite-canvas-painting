"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const typescript_1 = __importDefault(require("typescript"));
const utils_1 = require("../utils");
const defaultOptions = {
    configFilePath: "tsconfig.json",
    noEmit: true,
};
class TypeScriptLinter {
    constructor(options) {
        this.name = "TypeScriptLinter";
        this.formatHost = {
            getCanonicalFileName: (f) => f,
            getCurrentDirectory: process.cwd,
            getNewLine: () => "\n",
        };
        this.optionsLoadedFromFile = false;
        this.watchingFiles = [];
        this.watcher = null;
        this.options = Object.assign(Object.assign({}, defaultOptions), options);
    }
    async format(results) {
        return typescript_1.default.formatDiagnosticsWithColorAndContext(results, this.formatHost);
    }
    async lintBuild(files) {
        if (!this.optionsLoadedFromFile) {
            this.loadOptions();
        }
        const allFiles = files.concat(this.getCustomTypeRootFiles());
        const program = typescript_1.default.createProgram(allFiles, this.options);
        return typescript_1.default.getPreEmitDiagnostics(program);
    }
    lintServe(files, output) {
        if (!this.optionsLoadedFromFile) {
            this.loadOptions();
            this.watchingFiles = this.watchingFiles.concat(this.getCustomTypeRootFiles());
        }
        if (files.some((f) => !this.watchingFiles.includes(f))) {
            this.watchingFiles = this.watchingFiles.concat(files).filter(utils_1.onlyUnique);
            if (this.watcher) {
                this.watcher.close();
            }
            const host = typescript_1.default.createWatchCompilerHost(this.watchingFiles, this.options, typescript_1.default.sys, undefined, (diagnostic) => {
                if (diagnostic.category !== typescript_1.default.DiagnosticCategory.Message &&
                    diagnostic.file) {
                    output({
                        [(0, utils_1.normalizePath)(diagnostic.file.fileName)]: diagnostic,
                    });
                }
            }, (diagnostic, newLine, options, errorCount) => {
                if (errorCount !== undefined && errorCount <= 0) {
                    output({});
                }
            });
            this.watcher = typescript_1.default.createWatchProgram(host);
        }
    }
    // Fix for ts api not respecting typeRoots option
    getCustomTypeRootFiles() {
        let files = [];
        if (this.options.typeRoots) {
            for (const root of this.options.typeRoots) {
                if (!root.includes("node_modules")) {
                    files = files.concat((0, utils_1.readAllFiles)(root, (f) => f.endsWith(".d.ts")));
                }
            }
        }
        return files;
    }
    loadOptions() {
        this.optionsLoadedFromFile = true;
        if (!this.options.configFilePath) {
            return;
        }
        const configPath = path_1.default.resolve(process.cwd(), this.options.configFilePath);
        const configContents = fs_1.default.readFileSync(configPath).toString();
        const configResult = typescript_1.default.parseConfigFileTextToJson(configPath, configContents);
        const compilerOptions = typescript_1.default.convertCompilerOptionsFromJson(configResult.config["compilerOptions"] || {}, process.cwd());
        this.options = Object.assign(Object.assign({}, compilerOptions.options), this.options);
    }
}
exports.default = TypeScriptLinter;
